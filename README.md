## Easyfuck Programming Language

Easyfuck is an open-source interpreted esoteric programming language designed as a derivative of Brainfuck, with enhancements aimed at improving usability. It offers features such as functions, initializer data, and more, all represented by ASCII characters.

### Getting Started

To begin using the Easyfuck interpreter, follow these steps:

1. **Clone the Repository**: Start by cloning the Easyfuck repository and navigating into it:
    ```powershell
    git clone https://github.com/Quadruplay/easyfuck
    cd easyfuck
    ```

2. **Install Dependencies**: Ensure that Node.js is installed, then proceed to install the required dependencies using npm:
    ```powershell
    npm install node
    npm install node-web-audio-api
    npm install -g @yao-pkg/pkg
    ```

3. **Run the Batch file**: 
    ```powershell
    ./RUNME.bat
    ```

4. **Install the official syntax highlighting extension for vscode (optional)**:

    https://marketplace.visualstudio.com/items?itemName=Quadruplay.easyfuck-syntax

Note: Easyfuck files must use the `.ef` file extension.

---


### Memory Management

Easyfuck operates on a right-infinite array of 8-bit cells, with the pointer indicating the current cell. Additionally, a separate 8-bit storage cell exists. The language provides commands for moving the pointer within the array:

| Command | Description |
|---------|-------------|
| `>`     | Moves the pointer one cell to the right. |
| `<`     | Moves the pointer one cell to the left. If the pointer reaches below the 0th cell, it loops around to the furthest explored cell to the right. |
| `J`     | Moves the pointer back to the 0th cell. |
| `U`     | Unexplores the furthest explored cell to the right, setting it to 0, and moving it back to the unexplored state. |
| `P`     | Moves the pointer to the right by the value of the signed integer stored in the cell at the pointer. Negative values move the pointer left. All unexplored cells passed by the pointer get explored, and if the pointer reaches below the 0th cell, it loops around.

In Easyfuck, the concept of an **explored cell** refers to any cell previously visited by the pointer or one that holds a non-zero value.

Note: Unexploring a cell while pointing to it immediately explores it again.

---

### Data Movement

Data manipulation in Easyfuck involves moving data around using the storage cell and three associated commands:

| Command | Description |
|---------|-------------|
| `$`     | Copies the contents of the cell at the pointer to the storage cell |
| `!`     | Copies the contents of the storage cell to the cell at the pointer |
| `S`     | Swaps the contents of the storage cell and the cell at the pointer |

---


### I/O Operations

Easyfuck supports conventional input and output operations through various commands:

| Command | Description |
|---------|-------------|
| `,`     | Waits for a character and puts its Unicode value modulo 256 into the cell at the pointer. |
| `.`     | Outputs the Unicode character associated with the value stored in the cell at the pointer. |
| `"`     | Waits for a number from 0 to 255 and puts it into the cell at the pointer. |
| `'`     | Outputs the value stored in the cell at the pointer as an unsigned integer. |
| `I`     | Waits for a number from 0 to 65536 and puts it into the bi-cell at the pointer. |
| `O`     | Outputs the value stored in the bi-cell at the pointer as an unsigned integer. |
| `R`     | Clears the output. |
| `L`     | Clears a single line of the output. |
| `Q`     | Waits for a character and puts its Unicode value modulo 256 into the cell at the pointer. If a character is not received promptly, it defaults to 0. The waiting time is calculated in milliseconds by multiplying the value of the cell at the pointer by 10. |
| `G`     | Moves the output cursor to the column decided by the value in the cell to the left, and the row decided by the cell at the pointer. |

In Easyfuck, a bi-cell refers to the cell at the pointer and the cell immediately to the left, acting together as a 16-bit number.

A command exists that modifies the output of `.`.

| Command | Description |
|---------|-------------|
| `H`     | Switches the output of `.` to use a different table. Using it again switches it back to the default |

<details>
<summary>The table below provides a more detailed representation:</summary>

| Value | Alt Character | Default Character | Value | Alt Character | Default Character | Value | Alt Character | Default Character | Value | Alt Character |  Default Character  |
|-------|-----------|-|-------|-----------|-|-------|-----------|-|-------|-----------|-|
| `0`   |   `‚îÄ`     | `NUL` | `64` |    `‚ñå`    | `@` | `128` |    `‚ôï`    | `PAD` | `192` |    `‡∂û`    | `√Ä`
| `1`   |   `‚îÇ`     | `SOH` | `65` |    `‚ñç`    | `A` | `129` |    `‚ôñ`    | `HOP` | `193` |    `Œë`    | `√Å`
| `2`   |   `‚îå`     | `STX` | `66` |    `‚ñé`    | `B` | `130` |    `‚ôó`    | `BPH` | `194` |    `Œí`    | `√Ç`
| `3`   |   `‚îê`     | `ETX` | `67` |    `‚ñè`    | `C` | `131` |    `‚ôò`    | `NBH` | `195` |    `Œì`    | `√É`
| `4`   |   `‚îî`     | `EOT` | `68` |    `‚ñê`    | `D` | `132` |    `‚ôô`    | `IND` | `196` |    `Œî`    | `√Ñ`
| `5`   |   `‚îò`     | `ENQ` | `69` |    `‚ñï`    | `E` | `133` |    `‚ô•`    | `NEL` | `197` |    `Œï`    | `√Ö`
| `6`   |   `‚îú`     | `ACK` | `70` |    `‚ññ`    | `F` | `134` |    `‚ô¶`    | `SSA` | `198` |    `Œñ`    | `√Ü`
| `7`   |   `‚î§`     | `BEL` | `71` |    `‚ñó`    | `G` | `135` |    `‚ô£`    | `ESA` | `199` |    `Œó`    | `√á`
| `8`   |   `‚î¨`     | `BS` | `72` |    `‚ñò`    | `H` | `136` |    `‚ô†`    | `HTS` | `200` |    `Œò`    | `√à`
| `9`   |   `‚î¥`     | `TAB` | `73` |    `‚ñô`    | `I` | `137` |    `‚ô©`    | `HTJ` | `201` |    `Œô`    | `√â`
| `10`  |   `‚îº`     | `LF` | `74` |    `‚ñö`    | `J` | `138` |    `‚ô™`    | `LTS` | `202` |    `Œö`    | `√ä`
| `11`  |   `‚ïê`     | `VT` | `75` |    `‚ñõ`    | `K` | `139` |    `‚ô´`    | `PLD` | `203` |    `Œõ`    | `√ã`
| `12`  |   `‚ïë`     | `FF` | `76` |    `‚ñú`    | `L` | `140` |    `‚ô¨`    | `PLU` | `204` |    `Œú`    | `√å`
| `13`  |   `‚ïí`     | `CR` | `77` |    `‚ñù`    | `M` | `141` |    `‚ô≠`    | `RI` | `205` |    `Œù`    | `√ç`
| `14`  |   `‚ïì`     | `SO` | `78` |    `‚ñû`    | `N` | `142` |    `‚ôÆ`    | `SS2` | `206` |    `Œû`    | `√é`
| `15`  |   `‚ïî`     | `SI` | `79` |    `‚ñü`    | `O` | `143` |    `‚ôØ`    | `SS3` | `207` |    `Œü`    | `√è`
| `16`  |   `‚ïï`     | `DLE` | `80` |    `‚ñë`    | `P` | `144` |    `‚ô∞`    | `DCS` | `208` |    `Œ†`    | `√ê`
| `17`  |   `‚ïñ`     | `DC1` | `81` |    `‚ñí`    | `Q` | `145` |    `‚öÄ`    | `PU1` | `209` |    `Œ°`    | `√ë`
| `18`  |   `‚ïó`     | `DC2` | `82` |    `‚ñì`    | `R` | `146` |    `‚öÅ`    | `PU2` | `210` |    `Œ£`    | `√í`
| `19`  |   `‚ïò`     | `DC3` | `83` |    `‚ñ†`    | `S` | `147` |    `‚öÇ`    | `STS` | `211` |    `Œ§`    | `√ì`
| `20`  |   `‚ïô`     | `DC4` | `84` |    `‚ñ°`    | `T` | `148` |    `‚öÉ`    | `CCH` | `212` |    `Œ•`    | `√î`
| `21`  |   `‚ïö`     | `NAK` | `85` |    `‚ñ¢`    | `U` | `149` |    `‚öÑ`    | `MW` | `213` |    `Œ¶`    | `√ï`
| `22`  |   `‚ïõ`     | `SYN` | `86` |    `‚ñ£`    | `V` | `150` |    `‚öÖ`    | `SPA` | `214` |    `Œß`    | `√ñ`
| `23`  |   `‚ïú`     | `ETB` | `87` |    `‚ñ§`    | `W` | `151` |    `‚öá`    | `EPA` | `215` |    `Œ®`    | `√ó`
| `24`  |   `‚ïù`     | `CAN` | `88` |    `‚ñ•`    | `X` | `152` |    `‚öâ`    | `SOS` | `216` |    `Œ©`    | `√ò`
| `25`  |   `‚ïû`     | `EM` | `89` |    `‚ñ¶`    | `Y` | `153` |    `‚öö`    | `SGCI` | `217` |    `Œ±`    | `√ô`
| `26`  |   `‚ïü`     | `SUB` | `90` |    `‚ñß`    | `Z` | `154` |    `‚ö†`    | `SCI` | `218` |    `Œ≤`    | `√ö`
| `27`  |   `‚ï†`     | `ESC` | `91` |    `‚ñ®`    | `[` | `155` |    `‚ö≤`    | `CSI` | `219` |    `Œ≥`    | `√õ`
| `28`  |   `‚ï°`     | `FS` | `92` |    `‚ñ©`    | `\` | `156` |    `‚ö≥`    | `ST` | `220` |    `Œ¥`    | `√ú`
| `29`  |   `‚ï¢`     | `GS` | `93` |    `‚óÄ`    | `]` | `157` |    `‚ö¥`    | `OSC` | `221` |    `Œµ`    | `√ù`
| `30`  |   `‚ï£`     | `RS` | `94` |    `‚ñ≤`    | `^` | `158` |    `‚öµ`    | `PM` | `222` |    `Œ∂`    | `√û`
| `31`  |   `‚ï§`     | `US` | `95` |    `‚ñ∂`    | `_` | `159` |    `‚ö∂`    | `APC` | `223` |    `Œ∑`    | `√ü`
| `32`  |   `‚ï•`     | `Space` | `96` |    `‚ñº`    | `` ` `` | `160` |    `‚ö∑`    | `NBSP` | `224` |    `Œ∏`    | `√†`
| `33`  |   `‚ï¶`     | `!` | `97` |    `‚óÜ`    | `a` | `161` |    `‚ö∏`    | `¬°` | `225` |    `Œπ`    | `√°`
| `34`  |   `‚ïß`     | `"` | `98` |    `‚ñÆ`    | `b` | `162` |    `‚öø`    | `¬¢` | `226` |    `Œ∫`    | `√¢`
| `35`  |   `‚ï®`     | `#` | `99` |    `‚ñ¨`    | `c` | `163` |    `‚õÄ`    | `¬£` | `227` |    `Œª`    | `√£`
| `36`  |   `‚ï©`     | `$` | `100`|    `‚óè`    | `d` | `164` |    `‚õÅ`    | `¬§` | `228` |    `Œº`    | `√§`
| `37`  |   `‚ï™`     | `%` | `101`|    `‚òÑ`    | `e` | `165` |    `‚õÇ`    | `¬•` | `229` |    `ŒΩ`    | `√•`
| `38`  |   `‚ï´`     | `&` | `102`|    `‚òÖ`    | `f` | `166` |    `‚õÉ`    | `¬¶` | `230` |    `Œæ`    | `√¶`
| `39`  |   `‚ï¨`     | `'` | `103`|    `‚òÜ`    | `g` | `167` |    `‚õÜ`    | `¬ß` | `231` |    `Œø`    | `√ß`
| `40`  |   `‚ï≠`     | `(` | `104`|    `‚òê`    | `h` | `168` |    `‚õá`    | `¬®` | `232` |    `œÄ`    | `√®`
| `41`  |   `‚ïÆ`     | `)` | `105`|    `‚òú`    | `i` | `169` |    `‚õ§`    | `¬©` | `233` |    `œÅ`    | `√©`
| `42`  |   `‚ïØ`     | `*` | `106`|    `‚òû`    | `j` | `170` |    `‚õß`    | `¬™` | `234` |    `œÇ`    | `√™`
| `43`  |   `‚ï∞`     | `+` | `107`|    `‚ò¢`    | `k` | `171` |    `‚õ≠`    | `¬´` | `235` |    `œÉ`    | `√´`
| `44`  |   `‚ï±`     | `,` | `108`|    `‚ò£`    | `l` | `172` |    `êï£`    | `¬¨` | `236` |    `œÑ`    | `√¨`
| `45`  |   `‚ï≤`     | `-` | `109`|    `‚ò§`    | `m` | `173` |    `‚õâ`    | ¬≠`SHY` | `237` |    `œÖ`    | `√≠`
| `46`  |   `‚ï≥`     | `.` | `110`|    `‚ò•`    | `n` | `174` |    `‚õä`    | `¬Æ` | `238` |    `œÜ`    | `√Æ`
| `47`  |   `‚ï¥`     | `/` | `111`|    `‚ò≠`    | `o` | `175` |    `üï≠`    | `¬Ø` | `239` |    `œá`    | `√Ø`
| `48`  |   `‚ïµ`     | `0` | `112`|    `‚ò∫`    | `p` | `176` |    `üïÆ`    | `¬∞` | `240` |    `œà`    | `√∞`
| `49`  |   `‚ï∂`     | `1` | `113`|    `‚òª`    | `q` | `177` |    `üï±`    | `¬±` | `241` |    `œâ`    | `√±`
| `50`  |   `‚ï∑`     | `2` | `114`|    `‚òº`    | `r` | `178` |    `üïæ`    | `¬≤` | `242` |    `‚Ç¨`    | `√≤`
| `51`  |   `‚ñÄ`     | `3` | `115`|    `‚òâ`    | `s` | `179` |    `üñÇ`    | `¬≥` | `243` |    `ìÅå`    | `√≥`
| `52`  |   `‚ñî`     | `4` | `116`|    `‚òΩ`    | `t` | `180` |    `üó≤`   | `¬¥` | `244` |    `ìÉí`   | `√¥`
| `53`  |   `‚ñÅ`     | `5` | `117`|    `‚òæ`    | `u` | `181` |    `‚öê`   | `¬µ` | `245` |    `ìÉó`   | `√µ`
| `54`  |   `‚ñÇ`     | `6` | `118`|    `‚òø`    | `v` | `182` |    `‚öë`   | `¬∂` | `246` |    `ìÉ©`   | `√∂`
| `55`  |   `‚ñÉ`     | `7` | `119`|    `‚ôÄ`    | `w` | `183` |    `üóø`   | `¬∑` | `247` |    `ìÖÉ`   | `√∑`
| `56`  |   `‚ñÑ`     | `8` | `120`|    `‚ôÅ`    | `x` | `184` |    `‚≠†`   | `¬∏` | `248` |    `ìÜà`   | `√∏`
| `57`  |   `‚ñÖ`     | `9` | `121`|    `‚ôÇ`    | `y` | `185` |    `‚≠°`   | `¬π` | `249` |    `ìÜå`   | `√π`
| `58`  |   `‚ñÜ`     | `:` | `122`|    `‚ôÉ`    | `z` | `186` |    `‚≠¢`   | `¬∫` | `250` |    `ìÜâ`   | `√∫`
| `59`  |   `‚ñá`     | `;` | `123`|    `‚ôÑ`    | `{` | `187` |    `‚≠£`   | `¬ª` | `251` |    `ìÜè`   | `√ª`
| `60`  |   `‚ñà`     | `<` | `124`|    `‚ôÖ`    | <code>&#124;</code> | `188` |    `‚≠¶`   | `¬º` | `252` |    `ìÜô`   | `√º`
| `61`  |   `‚ñâ`     | `=` | `125`|    `‚ôÜ`    | `}` | `189` |    `‚≠ß`   | `¬Ω` | `253` |    `ìÜü`   | `√Ω`
| `62`  |   `‚ñä`     | `>` | `126`|    `‚ôá`    | `~` | `190` |    `‚≠®`   | `¬æ` | `254` |    `ìÜ§`   | `√æ`
| `63`  |   `‚ñã`     | `?` | `127`|    `‚ôî`    | `DEL` | `191` |    `‚≠©`   | `¬ø` | `255` |    `ìÜ£`   | `√ø`
</details>

---


### Additional Output Commands

Two additional commands exist for producing output:

| Command | Description |
|---------|-------------|
| `T`     | Produces a sound with the tone defined by the cell at the pointer and length defined by the cell to the right. This operation does not pause the program. |
| `K`     | Changes the color of the characters produced henceforth. |

The color produced by the `K` command is derived from the value of the byte at the pointer and is encoded as follows:

| Bit(s) | Function       |
|--------|----------------|
| `128`  | Toggles blinking on and off |
| `64`   | Toggles underline on and off |
| `32`, `16` | Red    |
| `8`, `4` | Green  |
| `2`, `1` | Blue   |

---


### Arithmetic Operations

Arithmetic operations enable mathematical computations within Easyfuck programs:

| Command | Description |
|---------|-------------|
| `+`     | Increments the cell at the pointer. |
| `-`     | Decrements the cell at the pointer. |
| `=`     | Adds the value of the storage cell to the value in the cell at the pointer, and stores the result in the cell at the pointer. |
| `_`     | Subtracts the value of the storage cell from the value in the cell at the pointer, and stores the result in the cell at the pointer. |
| `*`     | Multiplies the value in the cell at the pointer by the value of the storage cell, and stores the result in the cell at the pointer. |
| `M`     | Multiplies the value of the bi-cell at the pointer by the value of the storage cell, and stores the result in the bi-cell at the pointer. |
| `/`     | Divides the value in the cell at the pointer by the value of the storage cell, and stores the quotient in the cell at the pointer. |
| `N`     | Divides the value of the bi-cell at the pointer by the value of the storage cell, and stores the quotient in the bi-cell at the pointer. |
| `\`     | Calculates the square root of the value in the cell at the pointer, and stores the result in the cell at the pointer. |
| `V`     | Calculates the square root of the value of the bi-cell at the pointer, and stores the result in the bi-cell at the pointer. |
| `%`     | Computes the remainder of dividing the value in the cell at the pointer by the value of the storage cell, and stores the result in the cell at the pointer. |
| `:`     | Finds the maximum value between the cell at the pointer and the storage cell, and stores the result in the cell at the pointer. |

Division by 0 is handled by assuming a cut-off 9-bit divisor: `0b100000000`, effectively dividing by 256.

To simplify number generation, Easyfuck introduces hexadecimal commands:

| Command | Description |
|---------|-------------|
| `0`-`9` `A`-`F` | Sets the value of the cell at the pointer to the corresponding hexadecimal value multiplied by 16. |

---


### Bitwise Operations

For precise data manipulation, Easyfuck provides bitwise operations:

| Command | Description |
|---------|-------------|
| `{`     | Performs a left logical shift on the value of the cell at the pointer. |
| `}`     | Performs a right logical shift on the value of the cell at the pointer. |
| `~`     | Performs a bitwise NOT on the value of the cell at the pointer. |
| <code>&#124;</code>     | Performs a bitwise OR between the value of the cell at the pointer and the value of the storage cell, storing the result in the cell at the pointer. |
| `&`     | Performs a bitwise AND between the value of the cell at the pointer and the value of the storage cell, storing the result in the cell at the pointer. |
| `^`     | Performs a bitwise XOR between the value of the cell at the pointer and the value of the storage cell, storing the result in the cell at the pointer. |
| `Y`     | Reverses the order of bits of the value in the cell at the pointer. |

---


### Functions

Functions in Easyfuck can only be assigned to lowercase letters, following this syntax:

```
f(++++)
```

The code snippet above assigns the function `f` to execute the instructions `++++`. Once assigned, `f` will execute `++++` whenever invoked. Functions can be freely reassigned.

---


### Control Flow

Before discussing control flow commands, let's address miscellaneous commands:

| Command | Description |
|---------|-------------|
| `#`     | Initiates a comment that ends with another `#` or a new line |
| `W`     | Suspends program execution for a duration specified by the value of the cell at the pointer, multiplied by 10 milliseconds |
| `Z`     | Sets the value of the bi-cell at the pointer to the number of seconds elapsed since the start of the program |
| `?`     | Assigns a random value between 0 and 255 to the cell at the pointer |

In Easyfuck, two primary control flow structures exist:

- While Loops
- Conditional Statements

**While loops** are constructed using the following commands:

| Command | Description |
|---------|-------------|
| `[`     | Initiates a while loop |
| `]`     | Terminates a while loop |

While loops in Easyfuck lack explicit conditional statements. Instead, they continue execution as long as the value of the cell at the pointer evaluates to true.

Crude conditional statements can be formed using while loops, as shown in the following example:
```
[					# Start of loop A
	f				# Some code represented by function f
	0
]					# End of loop A
```
In this example, if the byte at the pointer is true, execution enters the loop, executes some code, resets the cell at the pointer, and exits the loop. This method overwrites a cell, which, while not problematic, may require additional steps such as replacing `0]` with `S0]S` or copying the cell elsewhere. To address this, breaks have been introduced:

| Command | Description |
|---------|-------------|
| `;`     | Exits the innermost while loop; if not within one, acts as `@` |
| `@`     | Exits the innermost function; if not within one, acts as `X` |
| `X`     | Terminates the program |

This allows conditional statements to avoid interference with stored data when rewritten, such as:
```
[f;]
```
However, more complex conditions can be created, as demonstrated in the next section.

**Conditional Statements** are best achieved using the `` ` `` command:

| Command | Description |
|---------|-------------|
| `` ` `` | Skips the next command unless the previous command sets the overflow flag |

Notably, chaining two `` ` `` commands skips the subsequent command only if the one before them set the overflow flag. Below is a table of commands that set the overflow flag and their requirements:

| Command | Sets the flag when: |
|---------|---------------------|
| `>`     | Moving the pointer to an unexplored cell |
| `<`     | Looping the pointer around |
| `U`     | Pointing to an unexplored cell, thus exploring it immediately |
| `P`     | Looping the pointer around or exploring new cells |
| `+`     | Overflowing the cell at the pointer |
| `-`     | Underflowing the cell at the pointer |
| `=`     | Overflowing the cell at the pointer |
| `_`     | Underflowing the cell at the pointer |
| `*`     | Overflowing the cell at the pointer |
| `M`     | Overflowing the bi-cell at the pointer |
| `}`     | The lost bit is a 1 |
| `{`     | The lost bit is a 1 |

---


### Lambdas

Lambdas in Easyfuck are functions that are not assigned to a variable and are executed immediately. They are primarily used when you want to skip multiple commands or break out of several nested while loops.

Consider the following example:
```
[ code [ more code [ still more code ; ] even more code ] code. again ]
```
In this example, the `;` command will break only out of the innermost loop. To break out of all nested loops, you can enclose them within a lambda and use `@` to break out of it:
```
( [ code [ more code [ still more code @ ] even more code ] code. again ] )
```
Another use for lambdas is to skip multiple commands. For instance:
```
code `(lambda code)
```

---


### Initializer Data

If you've followed all the steps so far and tried writing a program yourself, you might have encountered an issue when including the `@` symbol. This is because, aside from breaking from functions, `@` is also used to mark the end of the code. 

For example:
```
f('>$<!>>$<!<$>>=`@>.<<<f)>+>+>2<<<f>.<<<'2.>'
```
will be executed as:
```
f('>$<!>>$<!<$>>=`@
```

What happens to the rest of the code? It is used to initialize the array, setting it to:
```
>.<<<f)>+>+>2<<<f>.<<<'2.>'
```
In order to execute everything normally, another `@` is needed at the end of the code:
```
f('>$<!>>$<!<$>>=`@>.<<<f)>+>+>2<<<f>.<<<'2.>'@
```

---

### Example programs
#### Hello World:
```
[.>]@Hello World!
```
#### Fibonacci generator:
```
a(<+`X>)b(=`a)l(<<)r(>>)	#helper functions
f(r$l!>$l!>rr$l!>$l!>rll<$rr=`X>ll$rrbOr.lllf)	#recursive generating-printing function
[.>]1----.0>O2.0r+O2.0+r+O2.0+r2lllf	#initializer data printer, and fibonacci data pregen
@Fibonacci:
```
#### Prime generator:
```
#Array structure:
#cell           space character
#bi-cell        checked number
#bi-cell        copy of checked number (for checking)
#bi-cell        copy of checked number (for comparisons)
#bi-cell        sqrt of checked number (for optimization)

a(<+`X>)i(+`a)  #defining a bi-cell incrementing function i
b(<->)d(-`b)    #defining a bi-cell decrementing function d
r(<$>>!<$>>!)   #defining a function r that copies the current bi-cell to the bi-cell to the right and moves the pointer to it
f(J>>)          #defining a function f that goes back to the first bi-cell
p(fO<<.>>)      #defining a function p that prints the first bi-cell and a space
c(<<<$>>^<$>>^) #defining function c that turns a bi-cell to zero if the bi-cell to the left is the same

[.>]J[U]        #printing and clearing memory
1------.2       #printing new line and setting first cell to a space character
>>iipip         #printing first 2 primes

l(
    fiirrrV     #increment number twice (primes other than 2 are odd) and initialize the other bi-cells
    $<<NM       #divide and multiply 3rd bi-cell by 4th
    c<$>=       #compare with 2nd to check if 3rd mod 4th is 0, afterwards collapse to single cell
    -`@0+       #if 0 break, else set to 1
    frr>>-      #copy 1st to 2nd and 3rd again, then decrement 4th
    -[+         #if 4th is one, skip while loop
    $<<NM       #repeat the steps from before
    c<$>=
    -`@0+
    frr>>-
    -]
    p           #print the number
)
[llfii]        #loop the checking function, incrementing 1st bi-cell twice every second run to target only number of form 6k+1 and 6k+5

#initializer data:
@Primes:
```
#### D6 roller:
```
#Array structure:
#cell           number of dice
#cell           6 (faces)
#cell           145 (die character)
#cell           random
#bi-cell        sum

[.0>]J              #print and reset initialized data
>1------.<          #print new line
"'>.0++++++>9+H     #put user input into cell 0, put 6 into cell 1 and storage, put 145 into cell 2, switch to game typeset
a(=`(<+>))          #define function a that adds storage to bi-cell at pointer
J[
    ->$>>?%$        #decrement cell 0 and generate random number 0-5
    <=._>+$>>       #print the correct die and increase random variable to 1-6
    a               #add rolled value to total sum
J]
1------H.           #print new line
>>>>>O              #print total sum
@Give number of dice:
```